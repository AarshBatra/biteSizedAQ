---
title: "22.ind.block.pm2.5.sat.data.processing.1998.2024"
author: "Aarsh Batra"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load libraries

```{r load_libraries}

#> libraries
library(tidyverse)
library(jsonlite)
library(here)
library(sf)
library(ggplot2)
library(geojson)
library(devtools)
library(geojsonio)
library(geojsonsf)
library(roxygen2)
library(magrittr)
library(stringr)
library(data.table)
library(viridis)
library(ggthemes)
library(hrbrthemes)
library(RColorBrewer)
library(haven)
library(janitor)
library(lwgeom)
library(rvest)
library(dplyr)
library(ggrepel)
library(ggsflabel)
library(fuzzyjoin)
library(tidytext)
library(tm)
library(wordcloud2)
library(recipes)
library(forcats)
library(sjlabelled) 
library(geoarrow) # for exporting shapefiles to a geoparquet format
library(paletteer)
library(jpeg)
library(patchwork)
library(ggtext)
library(readxl)
library(tictoc)
library(googlesheets4)
library(reticulate)
library(raster)
library(fasterize)
library(microbenchmark)
library(future)
library(raster)
library(rasterVis)
library(ncdf4)
library(lattice)
library(foster)
library(rgdal)
```


## Load relevant functions, global variables and parameters setup
```{r}
# load and automatically document all functions
load_all()
document()


#> Negation of the "%in%" operator function
`%notin%` <- Negate(`%in%`)

#> shrug district level shapefile with uid for rasterization
shrug_master_district_shp <- st_read(str_c(here(), "/data/raw/shrug/shrug_master_district_shp_with_uid_for_rast_wa.gpkg"))

#> shrug subdistrict level shapefile with uid for rasterization
shrug_master_subdist_shp <- st_read(str_c(here(), "/data/raw/shrug/shrug_master_subdistrict_shp_with_uid_for_rast_wa.gpkg"))

shrug_master_subdist_shp <- shrug_master_subdist_shp %>%
  dplyr::mutate(uid_for_rasterization = row_number()) %>%
  dplyr::select(-geom, geom) %>%
  st_as_sf()

#> state level shapefile
ind_st_level_shp <- st_read(str_c(here(), "/data/raw/other.datasets/shpfiles/global_state.shp"))

ind_st_level_shp <- ind_st_level_shp %>%
  dplyr::filter(name0 == "India")


#> load in a single pollution raster, and crop it to India
#> 
pol_raster_path_vec <- list.files("./data/raw/monthly_pm2.5_v5.gl.06_raw_rasters_0.01_0.01_1998_2024_asia/Monthly/", full.names = TRUE, recursive = TRUE) 

#> load in the population raster
unit_pop_raster <- raster("./data/raw/landscan-global-2024-assets/landscan-global-2024.tif")

yearly_data_processed_list <- list()
  
#> [To be set by user]set the ref admin layer to be used for cropping and masking global rasters: using less detailed layers make cropping and masking more efficient later on
ref_admin_level_shp_file <- shrug_master_district_shp

#> [To be set by user] set the ref admin layer
ref_shp_file_to_be_rasterized <- shrug_master_subdist_shp


#> Set parameters for raw pollution rasters (check for a given raster once a year once data is downloaded from ACAG website)
pm25_rast_name <- "GWRPM25"
lat_rast_name <- "lat"
lon_rast_name <- "lon"

```


## Process satellite derived PM2.5 data and produced population weighted PM2.5 at Pakistan tehsil level by year in a loop
```{r process_satellite_data_in_loop}

for(i in 143 : length(pol_raster_path_vec)){

## testing
# if(i == 7){
#   break
# }  
  
tic()
  
  cur_rast_year <- as.numeric(str_remove(str_extract(pol_raster_path_vec[i], "\\d+\\.nc"), "\\d{2}.nc"))
  
  cur_rast_month <- as.numeric(str_remove((str_extract(str_extract(pol_raster_path_vec[i], "\\d+\\.nc"), "\\d{2}.nc")), ".nc"))
  
  cur_rast_month <- str_to_lower(month.name[cur_rast_month])

  print(str_c(cur_rast_year, "-", cur_rast_month, ": ", " (", i, "/", length(pol_raster_path_vec), ") pm2.5 pol data processing r1 starts!"))
    
  unit_pol_raster <- map(pol_raster_path_vec[i], ~nc_to_raster_layer(., pm25_rast_name, lat_rast_name, lon_rast_name), .progress = TRUE)

#> crop the unit_raster using ref shp
unit_pol_raster_cropped_admin_lev_shp_file <- raster::crop(unit_pol_raster[[1]], ref_admin_level_shp_file)

#> mask the unit raster using ref shp
unit_pol_raster_cropped_admin_lev_shp_file_mask <- mask(unit_pol_raster_cropped_admin_lev_shp_file, ref_admin_level_shp_file)

#> clamp the pol raster, to replace any negative value pixels with pixels of value = 0, as pollution concentrations cannot have negative values
unit_pol_raster_cropped_admin_lev_shp_file_mask <- terra::clamp(
  unit_pol_raster_cropped_admin_lev_shp_file_mask,
  lower = 0,  # Any value below 0 will be set to 0
  values = TRUE  # Apply the threshold and replace values below 0 with 0
)

#> crop the population raster
unit_pop_raster_cropped_admin_lev_shp_file <- raster::crop(unit_pop_raster, ref_admin_level_shp_file)

#> mask the population raster
unit_pop_raster_cropped_admin_lev_shp_file_mask <- mask(unit_pop_raster_cropped_admin_lev_shp_file, ref_admin_level_shp_file)

#> clamp the pop raster, to replace any negative value pixels with pixels of value = 0, as population cannot have negative values
unit_pop_raster_cropped_admin_lev_shp_file_mask <- terra::clamp(
 unit_pop_raster_cropped_admin_lev_shp_file_mask,
  lower = 0,  # Any value below 0 will be set to 0
  values = TRUE  # Apply the threshold and replace values below 0 with 0
)


#> match pol raster to pop raster
unit_pol_raster_cropped_admin_lev_shp_file_mask_match_pop <- matchResolution(unit_pol_raster_cropped_admin_lev_shp_file_mask, unit_pop_raster_cropped_admin_lev_shp_file_mask)

#> fasterize the village level shapefile (with a uid for rasterization) to the same resolution as the pop, pol rasters
sh_admin_int_shp_rasterized <- fasterize(ref_shp_file_to_be_rasterized, unit_pol_raster_cropped_admin_lev_shp_file_mask_match_pop, field = "uid_for_rasterization", fun = "last")

#> set names for rasters

names(unit_pol_raster_cropped_admin_lev_shp_file_mask_match_pop) <- "pol_rast"
names(unit_pop_raster_cropped_admin_lev_shp_file_mask) <- "pop_rast"
names(sh_admin_int_shp_rasterized) <- "sh_rast"

#> create a raster brick out of pol rast, pop rast, sh vil rast
region_raster_brick <- sh_admin_int_shp_rasterized %>%
  addLayer(unit_pol_raster_cropped_admin_lev_shp_file_mask_match_pop) %>%
  addLayer(unit_pop_raster_cropped_admin_lev_shp_file_mask)

#> create a df out of the brick
region_raster_brick_df <- raster::as.data.frame(region_raster_brick)
region_raster_brick_df <- region_raster_brick_df %>%
  dplyr::filter(!is.na(pol_rast), !is.na(pop_rast))

#> create an arrow table from the df before collapsing
region_raster_brick_df_arrow <- region_raster_brick_df %>%
  arrow::as_arrow_table()

#> collapse arrow table
region_raster_brick_df_arrow_collapse <- region_raster_brick_df_arrow %>%
  # dplyr::filter((!is.na(sh_rast)) & ((as.character(sh_rast) != "NA"))) %>%
  dplyr::group_by(sh_rast) %>%
  dplyr::collect() %>%
  dplyr::mutate(pop_weights = pop_rast/sum(pop_rast, na.rm = TRUE), 
         pollution_pop_weighted = pop_weights*pol_rast) %>%
  dplyr::summarise(total_population = sum(pop_rast, na.rm = TRUE), 
            avg_pm2.5_pollution = sum(pollution_pop_weighted, na.rm = TRUE)) %>%
  dplyr::ungroup() 

#> shrug ids not captured in the first round of processing
uids_not_captured_r1 <- ref_shp_file_to_be_rasterized$uid_for_rasterization[ref_shp_file_to_be_rasterized$uid_for_rasterization %notin% region_raster_brick_df_arrow_collapse$sh_rast]

#> uids with NA pop
uids_with_na_pop <- region_raster_brick_df_arrow_collapse %>% dplyr::filter(is.na(total_population)) %>% 
  dplyr::select(sh_rast) %>%
  unlist() %>%
  as.vector()

#> uids with NA pol
uids_with_na_pol <- region_raster_brick_df_arrow_collapse %>% dplyr::filter(is.na(avg_pm2.5_pollution)) %>% 
  dplyr::select(sh_rast) %>%
  unlist() %>%
  as.vector()

#> uids with 0 population
uids_with_zero_pop <- region_raster_brick_df_arrow_collapse %>%
  dplyr::filter(total_population == 0) %>%
  dplyr::select(sh_rast) %>%
  unlist() %>%
  as.vector()

#> concat all unprocessed shrud ids into a single vector
uids_not_captured_master_r1 <- c(uids_not_captured_r1, uids_with_na_pop, uids_with_na_pol, uids_with_zero_pop)
uids_not_captured_master_r1 <- uids_not_captured_master_r1 %>%
  unique()

#> resample and capture uncaptured blocks
if(length(uids_not_captured_master_r1) == 0){
  print("all blocks captured in first round, resampling not needed")
  region_raster_brick_df_arrow_collapse_final <- region_raster_brick_df_arrow_collapse

#> rename pollution column
colnames(region_raster_brick_df_arrow_collapse_final)[colnames(region_raster_brick_df_arrow_collapse_final) == "avg_pm2.5_pollution"] <- str_c("avg_pm2.5_", cur_rast_year)

yearly_data_processed_list[[i]] <- region_raster_brick_df_arrow_collapse_final

print(str_c(cur_rast_year, " pm2.5 pol data processing r1 completed!"))


  next
} else {
  


### Process unprocess shrug ids by resampling======================================================

#> resampling details

print(str_c(cur_rast_year, "capturing residual tiny blocks..."))

resample_to_res <- 0.001 
res_resample_from <- 0.00833333
resample_obj_capture_list <- list()

#> restricting the shp file to the unprocessed shr ids that will be processed one at a time
sh_admin_int_shp_unprocessed  <- ref_shp_file_to_be_rasterized  %>%
  filter(uid_for_rasterization %in% uids_not_captured_master_r1)


if(length(sh_admin_int_shp_unprocessed))

#> reprocessing unprocessed shr ids one at a time
for (j in 1 : length(uids_not_captured_master_r1)){
  
  # rasterize shpfile to the current unprocessed shr id
  sh_admin_int_shp_unprocessed_rasterized <- fasterize(sh_admin_int_shp_unprocessed %>% filter(uid_for_rasterization == uids_not_captured_master_r1[j]), raster::raster(ext = raster::extent(sh_admin_int_shp_unprocessed %>% filter(uid_for_rasterization == uids_not_captured_master_r1[j])), resolution = resample_to_res, crs = crs(sh_admin_int_shp_unprocessed)), field = "uid_for_rasterization", fun = "last")
  
  # set name of the rasterized shapefile
  names(sh_admin_int_shp_unprocessed_rasterized) <- "sh_rast"
  
  # crop pol raster to the cur unprocessed shr id
  unit_pol_raster_crop_unproc <- raster::crop(unit_pol_raster[[1]], sh_admin_int_shp_unprocessed_rasterized)
  
  # resample to the new resolution
  unit_pol_raster_crop_unproc_resample <- raster::resample(unit_pol_raster_crop_unproc, sh_admin_int_shp_unprocessed_rasterized, method = "ngb")
  
  # mask resampled pol raster to the cur unprocessed shr id
   unit_pol_raster_crop_unproc_resample_mask <- raster::mask(unit_pol_raster_crop_unproc_resample, sh_admin_int_shp_unprocessed_rasterized)
   
  #> clamp the pol raster, to replace any negative value pixels with pixels of value = 0, as pollution concentrations cannot have negative values
unit_pol_raster_crop_unproc_resample_mask <- terra::clamp(
  unit_pol_raster_crop_unproc_resample_mask,
  lower = 0,  # Any value below 0 will be set to 0
  values = TRUE  # Apply the threshold and replace values below 0 with 0
) 
   
    # crop pop raster to the cur unprocessed shr id
  unit_pop_raster_crop_unproc <- crop(unit_pop_raster, sh_admin_int_shp_unprocessed_rasterized)
  
  # replace population values with population densities before resampling
  raster::values(unit_pop_raster_crop_unproc) <- as.vector(unit_pop_raster_crop_unproc * (((resample_to_res)^2)/((res_resample_from)^2)))
  
  # resample to the new resolution
  unit_pop_raster_crop_unproc_resample <- raster::resample(unit_pop_raster_crop_unproc, sh_admin_int_shp_unprocessed_rasterized, method = "ngb")
  
  # mask resampled pop raster to the cur unprocessed shr id
   unit_pop_raster_crop_unproc_resample_mask <- raster::mask(unit_pop_raster_crop_unproc_resample, sh_admin_int_shp_unprocessed_rasterized)
   
    #> clamp the pop raster, to replace any negative value pixels with pixels of value = 0, as population cannot have negative values
unit_pop_raster_crop_unproc_resample_mask <- terra::clamp(
  unit_pop_raster_crop_unproc_resample_mask,
  lower = 0,  # Any value below 0 will be set to 0
  values = TRUE  # Apply the threshold and replace values below 0 with 0
) 
   #> set names for rasters

names(unit_pol_raster_crop_unproc_resample_mask) <- "pol_rast"
names(unit_pop_raster_crop_unproc_resample_mask) <- "pop_rast"
names(sh_admin_int_shp_unprocessed_rasterized) <- "sh_rast"
   
  
  #> create a raster brick out of pol rast, pop rast, sh vil rast
region_raster_brick_resample <- sh_admin_int_shp_unprocessed_rasterized %>%
  addLayer(unit_pol_raster_crop_unproc_resample_mask) %>%
  addLayer(unit_pop_raster_crop_unproc_resample_mask)

#> create a df out of the brick
region_raster_brick_df_resample <- raster::as.data.frame(region_raster_brick_resample)
region_raster_brick_df_resample <- region_raster_brick_df_resample %>%
  dplyr::filter(!is.na(pol_rast), !is.na(pop_rast))

#> create an arrow table from the df before collapsing
region_raster_brick_df_arrow_resample <- region_raster_brick_df_resample %>%
  arrow::as_arrow_table()

#> collapse arrow table
region_raster_brick_df_arrow_collapse_resample <- region_raster_brick_df_arrow_resample %>%
  # dplyr::filter((!is.na(sh_rast)) & ((as.character(sh_rast) != "NA"))) %>%
  dplyr::group_by(sh_rast) %>%
  dplyr::collect() %>%
  dplyr::mutate(pop_weights = pop_rast/sum(pop_rast, na.rm = TRUE), 
         pollution_pop_weighted = pop_weights*pol_rast) %>%
  dplyr::summarise(total_population = sum(pop_rast, na.rm = TRUE), 
            avg_pm2.5_pollution = sum(pollution_pop_weighted, na.rm = TRUE)) %>%
  dplyr::ungroup() 

resample_obj_capture_list[[j]] <- region_raster_brick_df_arrow_collapse_resample

print(str_c(j, " out of ", length(uids_not_captured_master_r1), " tiny blocks reprocessed!"))


}

#> rbind all residual blocks captured in r2 of processing
resample_obj_capture_df <- resample_obj_capture_list %>%
  rbindlist() %>%
  as_tibble()

#> rbind the residual blocks processed in r2 with the blocks from r1
region_raster_brick_df_arrow_collapse_final <- region_raster_brick_df_arrow_collapse %>%
  rbind(resample_obj_capture_df) %>%
  arrange(sh_rast)

}

#> rename pollution column
colnames(region_raster_brick_df_arrow_collapse_final)[colnames(region_raster_brick_df_arrow_collapse_final) == "avg_pm2.5_pollution"] <- str_c("avg_pm2.5_", cur_rast_year, "_", cur_rast_month)

yearly_data_processed_list[[i]] <- region_raster_brick_df_arrow_collapse_final

yearly_data_processed_list[[i]] %>%
  writexl::write_xlsx(paste0("./data/intermediate/22.ind.block.pm2.5.sat.data.processing.1998.2024/monthly_pm2.5_v5.gl.06_0.01_0.01_1998_2024_asia/year-month-datasets/", "avg_pm2.5_", cur_rast_year, "_", cur_rast_month, ".xlsx"))

print(str_c(cur_rast_year, "-", cur_rast_month, ": ", " pm2.5 pol data processing fully completed and files preserved!"))




toc()  
}



```

## create a master final SHRUG mapped dataset

```{r master_sh_map_data_create}

#### uncomment and run this (after updating appropriate ver of dataset) if you have already processed the month-year files above and want to directly load and perform remaining steps to finalize. 
# yearly_data_processed_list <- map(list.files("./data/intermediate/22.ind.block.pm2.5.sat.data.processing.1998.2024/monthly_pm2.5_v5.gl.06_0.01_0.01_1998_2024_asia/year-month-datasets/", full.names = TRUE), ~readxl::read_excel(.x), .progress = TRUE)

# removing any duplicate regions
yearly_data_processed_list_fin <- yearly_data_processed_list %>% map(~.x %>% distinct_all())

# adding a NA for pol where while population is 0
yearly_data_processed_list_fin <- yearly_data_processed_list_fin %>%   map(~ .x %>%
        mutate(across(starts_with("avg_pm2.5"),
                      ~ na_if(., 0))))

# creating a master dataset for all years from 1998 to 2024
final_all_years_cbind_df <- reduce(yearly_data_processed_list_fin, function(x, y) left_join(x, y, by = c("sh_rast", "total_population")))

# adding SHRUG admin area names from the block level shapefile
final_all_years_cbind_df_sh_mapped <- final_all_years_cbind_df %>%
  left_join(ref_shp_file_to_be_rasterized %>% st_drop_geometry(), by = c("sh_rast" = "uid_for_rasterization")) %>%
  dplyr::select(state_name, district_name, subdistrict_name, total_population, starts_with("avg_pm")) %>%
  rename(subdistrict_population = total_population)

final_all_years_cbind_df %>%  write_csv(paste0("./data/processed/22.ind.block.pm2.5.sat.data.processing.1998.2024/av_pm2.5_ind_blk_mth_1998_2024_wide.csv"))

# long form version of the dataset
final_all_years_cbind_df_sh_mapped_long <- final_all_years_cbind_df_sh_mapped %>% pivot_longer(cols = !c(state_name, district_name, subdistrict_name, subdistrict_population), names_to = c("year", "month"), names_pattern = "(\\d{4})_(.+)", values_to = "avg_pm2.5") %>%
  dplyr::mutate(year = as.numeric(year)) %>%
     dplyr::mutate(month = factor(month, 
                          levels = c("january", "february", "march", "april", "may", "june", 
                                     "july", "august", "september", "october", "november", "december"))) 

final_all_years_cbind_df_sh_mapped_long %>%  write_csv(paste0("./data/processed/22.ind.block.pm2.5.sat.data.processing.1998.2024/av_pm2.5_ind_blk_mth_1998_2024_long.csv"))

```


## [EXTRA CODE FOR PLOTTING, not part of main pipeline. Various experimenation plots, feel free to explore] Plotting a sample map: monthly avg pm2.5 in all years in a loop in India at block level in micrograms per cubic meter

```{r}

# #### If want to directly load the processed data (assuming data is already processed) and plot, uncomment the below code. Make sure to update the version and folder names of the data for which you want to make the plot. As of last time the latest data was 1998 to 2024
# # 
final_all_years_cbind_df_sh_mapped_long <- read_csv("./data/processed/22.ind.block.pm2.5.sat.data.processing.1998.2024/av_pm2.5_ind_blk_mth_1998_2024_long.csv")

# final_all_years_cbind_df_sh_mapped_wide <- read_csv("./data/processed/22.ind.block.pm2.5.sat.data.processing.1998.2024/av_pm2.5_ind_blk_mth_1998_2024_wide.csv")

#### plot monthly screenshot for all years for India at block level----------------------
ref_yr <- c(1998:2024)


for(i in 1 : length(ref_yr)){
plt1 <- final_all_years_cbind_df_sh_mapped_long %>%
  mutate(month = factor(month, levels = str_to_lower(month.name), labels = month.name)) %>%
  filter(year %in% c(ref_yr[i])) %>%
  left_join(
    shrug_master_subdist_shp %>%
      dplyr::select(state_name, district_name, subdistrict_name, geom), 
    by = c("state_name", "district_name", "subdistrict_name")
  ) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(aes(fill = avg_pm2.5), color = NA) +
  scale_fill_stepsn(
    colors = rev(viridisLite::magma(8)),
    breaks = c(0, 20, 40, 60, 100, 140, 220, 300),
    limits = c(0, 300),
    na.value = "white"
  ) +
  theme_map() +
  labs(
    fill = expression("Monthly Average" ~ PM[2.5] ~ "(μg/m³)"),
    title = expression("Block-level Monthly Average" ~ PM[2.5] ~ "Pollution in India"),
    subtitle = as.character(ref_yr[i]),
    caption = expression("Graphic · Aarsh Batra | github.com/AarshBatra/biteSizedAQ")
  ) +
  theme(
    legend.position = "bottom",  # Position legend at bottom of plot
    legend.justification = "center",  # Center the legend
    legend.direction = "horizontal",
    legend.key.width = unit(3, "cm"),
    legend.box.margin = margin(0, 0, 15, 0),  # Add space below legend
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    strip.background = element_blank(),
    strip.text = element_text(size = 13, face = "bold", family = "Mono"),
    plot.title = element_text(size = 20, family = "Mono", hjust = 0),
    plot.subtitle = element_text(size = 18, family = "Mono", hjust = 0, face = "bold", margin = margin(b = 1.5, unit = "cm")),
    legend.title = element_text(size = 14, family = "Mono", margin = margin(t = 0.2, unit = "cm")),
    legend.text = element_text(size = 12, family = "Mono"),
    plot.caption = element_text(size = 11, family = "Mono", margin = margin(t = 0.8, unit = "cm"), hjust = 0.5),
    plot.margin = margin(t = 0.3, r = 1, b = 0.3, l = 0.8, unit = "cm")
  ) +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5)) +
  facet_wrap(~month, nrow = 3)
ggsave(paste0("./22.ind.block.pm2.5.sat.data.processing.1998.2024/monthly.india.pm2.5.snapshot.all.yrs/mth_avg_pm2.5_india_snapshot_", ref_yr[i], ".png"), plt1, width = 10, height = 10, dpi = 520)

print(paste0(i, " out of ", length(ref_yr), " year snapshot saved!"))
}


#### plot for selected years for all months for IGP-----------------------

# Create your main plot 
plt1 <- final_all_years_cbind_df_sh_mapped_long %>%
  filter(year %in% c(1998, 2024), state_name %in% c("nct of delhi", "punjab", "haryana", "uttar pradesh", "bihar", "west bengal")) %>%
  mutate(month = factor(month, levels = str_to_lower(month.name), labels = month.abb)) %>%
  left_join(
    shrug_master_subdist_shp %>%
      dplyr::select(state_name, district_name, subdistrict_name, geom), 
    by = c("state_name", "district_name", "subdistrict_name")
  ) %>%
  st_as_sf() %>%
  ggplot() +
  geom_sf(aes(fill = avg_pm2.5), color = NA) +
  scale_fill_stepsn(
    colors = rev(viridisLite::magma(7)),
    breaks = c(0, 40, 80, 120, 200, 300),
    limits = c(0, 300),
    na.value = "white"
  ) +
  theme_map() +
  labs(
    fill = expression("Monthly Average" ~ PM[2.5] ~ "(μg/m³)"),
    title = expression("Block-level Monthly Average" ~ PM[2.5] ~ "Pollution in the Northern Plains of India"),
    caption = expression("Graphic · Aarsh Batra | github.com/AarshBatra/biteSizedAQ")
  ) +
  theme(
    legend.position = "bottom",
    legend.justification = "center",
    legend.direction = "horizontal",
    legend.key.width = unit(3, "cm"),
    legend.box.margin = margin(0, 0, 15, 0),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    strip.background = element_blank(),
    strip.text = element_text(size = 12, family = "Mono"),
    plot.title = element_text(size = 16, family = "Mono", hjust = 0, margin = margin(t = 0.5, b = 0.5, unit = "cm")),
    legend.title = element_text(size = 14, family = "Mono", margin = margin(t = 0.2, b = 0.1, unit = "cm")),
    legend.text = element_text(size = 12, family = "Mono"),
    plot.caption = element_text(size = 9, family = "Mono", margin = margin(t = 0.8, unit = "cm"), hjust = 0.5), 
    plot.margin = margin(l = 0.5, r = 0.5, unit = "cm")
  ) +
  guides(fill = guide_colorbar(title.position = "top", title.hjust = 0.5)) +
  facet_grid(month ~ year, switch = "y")   


# Save the map with high resolution
ggsave("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/igp_map_facetted.png", plt1, width = 15, height = 20, dpi = 420)

library(ggplot2)
library(dplyr)

# Assuming your data is in a dataframe called 'df'
# Filter for 1998 and 2024, calculate state-level statistics
state_stats <- final_all_years_cbind_df_sh_mapped_long %>%
  filter(year %in% c(1998, 2024)) %>%
  group_by(state_name, year) %>%
  summarise(
    min_pollution = min(avg_pm2.5, na.rm = TRUE),
    max_pollution = max(avg_pm2.5, na.rm = TRUE),
    mean_pollution = weighted.mean(avg_pm2.5, subdistrict_population, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  group_by(year) %>%
  arrange(mean_pollution) %>%
  mutate(state_name = tools::toTitleCase(state_name),
         state_order = row_number()) %>%
  ungroup()

# Create the plot
plt <- ggplot(state_stats, aes(y = reorder(state_name, state_order))) +
  # Add line segments from min to max with smokey effect
  geom_segment(aes(x = min_pollution, xend = max_pollution, 
                   yend = reorder(state_name, state_order), color = mean_pollution),
               linewidth = 2.5, alpha = 0.8) +
  # Add subtle shadow effect
  geom_segment(aes(x = min_pollution, xend = max_pollution, 
                   yend = reorder(state_name, state_order)),
               linewidth = 4, alpha = 0.15, color = "white") +
  # Add points for min, max, and mean with glow effect
  geom_point(aes(x = min_pollution), size = 5, shape = 21, 
             fill = "#2d2d2d", color = "#808080", stroke = 0.5, alpha = 0.9) +
  geom_point(aes(x = min_pollution), size = 3, shape = 21, 
             fill = "#404040", color = "#a0a0a0", stroke = 1) +
  geom_point(aes(x = max_pollution), size = 5, shape = 21, 
             fill = "#2d2d2d", color = "#808080", stroke = 0.5, alpha = 0.9) +
  geom_point(aes(x = max_pollution), size = 3, shape = 21, 
             fill = "#404040", color = "#a0a0a0", stroke = 1) +
  # Mean point with smokey glow
  geom_point(aes(x = mean_pollution, color = mean_pollution), 
             size = 7, shape = 16, alpha = 0.4) +
  geom_point(aes(x = mean_pollution, color = mean_pollution), 
             size = 5, shape = 16) +
  # Facet by year
  facet_wrap(~ year, ncol = 2, scales = "free_y") +
  # Color scale - smokey orange to hazardous red gradient
scale_color_gradientn(
  colors = c("#ffeda0", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"),
  values = scales::rescale(c(0, 0.15, 0.3, 0.5, 0.7, 0.85, 1)),
  limits = c(0, 175),
  breaks = seq(0, 150, by = 25),
  name = expression("Mean PM"[2.5]),
  guide = guide_colorbar(
    title.position = "top",
    barwidth = 15,
    barheight = 0.6,
    frame.colour = "#606060",
    ticks.colour = "#808080",
    nbin = 500
  )
) +
  # Add more x-axis breaks
  scale_x_continuous(n.breaks = 8) +
  # Add spacing between y-axis categories
  scale_y_discrete(expand = expansion(add = 0.6)) +
  # Labels and theme
labs(
  title = expression(bold("Air Quality Inequality Across Indian States")),
  subtitle = "PM2.5 range from cleanest to most polluted block-months, with population-weighted state means (1998 vs 2024)",
  x = expression("PM"[2.5]*" Level (µg/m³)"),
  y = "State", 
  caption = expression("Graphic · Aarsh Batra | github.com/AarshBatra/biteSizedAQ")
) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(size = 20, hjust = 0.5, color = "#E8E8E8", 
                              margin = margin(b = 10)),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "#B8B8B8",
                                 margin = margin(b = 25)),
    panel.grid = element_blank(),
    axis.text.y = element_text(size = 10, color = "#C8C8C8", margin = margin(r = 8)),
    axis.text.x = element_text(size = 10, color = "#C8C8C8", margin = margin(t = 15)),
    axis.title.x = element_text(color = "#B0B0B0", margin = margin(t = 20), size = 12),
    axis.title.y = element_text(color = "#B0B0B0", margin = margin(r = 20), size = 12),
    axis.ticks.length = unit(0.3, "cm"),
    legend.position = "top",
    legend.justification = "center",
    legend.direction = "horizontal",
    legend.text = element_text(color = "#C8C8C8", size = 10),
    legend.title = element_text(color = "#B0B0B0", size = 11, hjust = 0.5),
    legend.box.background = element_rect(fill = "#0f0f0f", color = NA),
    legend.margin = margin(5, 5, 10, 5),
    strip.text = element_text(color = "#E8E8E8", size = 14, face = "bold", 
                              margin = margin(b = 15)),
    strip.background = element_rect(fill = "#1a1a1a", color = NA),
    panel.spacing = unit(2, "lines"),
    plot.background = element_rect(fill = "#0f0f0f", color = NA),
    panel.background = element_rect(fill = "#0f0f0f", color = NA),
    legend.background = element_rect(fill = "#0f0f0f", color = NA),
    plot.margin = margin(25, 25, 25, 25), 
    plot.caption = element_text(size = 13, family = "Mono", color = "white", margin = margin(t = 0.8, unit = "cm"), hjust = 0.5)
  )

# If you want to save the plot
# ggsave("state_pollution_1998_vs_2024.png", width = 16, height = 12, dpi = 300)
# If you want to save the plot
ggsave("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/state_pollution_plot.png", plt, width = 22, height = 12, dpi = 300)

  
 # Load required libraries
library(tidyverse)
library(viridis)

#### animated bar chart state wise=============================================

library(ggplot2)
library(dplyr)
library(gganimate)
library(tidyr)

# Assuming your data is in a dataframe called 'df'
# Calculate annual state-level statistics with population-weighted mean
state_annual <- final_all_years_cbind_df_sh_mapped_long %>%
  group_by(state_name, year) %>%
  summarise(
    mean_pollution = weighted.mean(avg_pm2.5, subdistrict_population, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(state_name = tools::toTitleCase(state_name)) %>%
  group_by(year) %>%
  arrange(year, desc(mean_pollution)) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  mutate(state_name = ifelse(state_name == "Andaman Nicobar Islands", "A.N. Islands", state_name), 
         state_name = ifelse(state_name == "Arunachal Pradesh", "Arun. P.", state_name))

# Create the static plot
p <- ggplot(state_annual, aes(x = rank, y = mean_pollution, fill = mean_pollution)) +
    geom_hline(yintercept = 40, linetype = "dotted", color = "#FFA500", linewidth = 1.3) +
  geom_text(aes(x = max(rank), y = 83, label = "India Annual Avg PM2.5 Limit (40 µg/m³)"),
            hjust = 1, vjust = 2.7, size = 6, color = "#FFA500", fontface = "bold") +
  geom_hline(yintercept = 5, linetype = "dotted", color = "cornflowerblue", linewidth = 1.3) +
  geom_text(aes(x = max(rank), y = 32, label = "WHO Guideline (5 µg/m³)"),
            hjust = 1, vjust = 2.7, size = 6, color = "cornflowerblue", fontface = "bold") +
  geom_col(alpha = 0.9, width = 0.9) +
  # Add reference lines
  geom_text(aes(y = mean_pollution, label = state_name), 
            hjust = 1.05, 
            size = 5.5, 
            color = "#000000",
            fontface = "bold") +
  geom_text(aes(y = mean_pollution, label = sprintf("%.1f", mean_pollution)), 
            hjust = -0.15, 
            size = 5, 
            color = "#E8E8E8",
            fontface = "bold") +
  # Color scale - smokey gradient
  scale_fill_gradientn(
    colors = c("#FFE5B4", "#FFD700", "#FFA500", "#FF6347", "#DC143C", "#8B0000"),
    values = scales::rescale(c(0, 0.3, 0.5, 0.7, 0.85, 1)),
    name = expression("Mean PM"[2.5])
  ) +
  coord_flip(clip = "off") +
  scale_x_reverse() +
  labs(
    title = "India State Annual Average PM2.5 Rankings 1998-2024",
    subtitle = "Year: {closest_state}",
    x = NULL,
    y = "Population-Weighted Mean PM2.5 (µg/m³)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 22, hjust = 0.5, color = "#E8E8E8", 
                              face = "bold", margin = margin(b = 5)),
    plot.subtitle = element_text(size = 18, hjust = 0.5, color = "#FFD700",
                                 face = "bold", margin = margin(b = 20)),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 14, color = "#E8E8E8"),
    axis.title.x = element_text(size = 13, color = "#E8E8E8", margin = margin(t = 15)),
    axis.ticks = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "#2a2a2a", linewidth = 0.3),
    legend.position = "none",
    plot.background = element_rect(fill = "#0f0f0f", color = NA),
    panel.background = element_rect(fill = "#0f0f0f", color = NA),
    plot.margin = margin(20, 60, 20, 100)
  )

# Animate the plot
anim <- p +
  transition_states(year, 
                    transition_length = 2, 
                    state_length = 1) +
  ease_aes('cubic-in-out') +
  enter_fade() +
  exit_fade()

# Render the animation
p_anim <- animate(anim, 
        nframes = 300,
        fps = 10, 
        width = 1200, 
        height = 1200,
        renderer = gifski_renderer())

# Save the animation
anim_save("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/pollution_race.gif")




#### animated racing pollution chart region and airshed wise===================================
library(ggplot2)
library(dplyr)
library(gganimate)
library(tidyr)

# ============================================================================
# VERSION 1: POLITICAL REGIONS (5 categories)
# ============================================================================

library(ggplot2)
library(dplyr)
library(gganimate)
library(tidyr)

# ============================================================================
# VERSION 1: GEOGRAPHIC REGIONS (5 categories)
# ============================================================================

geographic_mapping <- tribble(
  ~state_name, ~region,
  # North & Central
  "Punjab", "North & Central",
  "Haryana", "North & Central",
  "Chandigarh", "North & Central",
  "Nct of Delhi", "North & Central",
  "Uttar Pradesh", "North & Central",
  "Uttarakhand", "North & Central",
  "Himachal Pradesh", "North & Central",
  "Jammu Kashmir", "North & Central",
  "Madhya Pradesh", "North & Central",
  "Chhattisgarh", "North & Central",
  
  # East
  "Bihar", "East",
  "Jharkhand", "East",
  "West Bengal", "East",
  "Odisha", "East",
  
  # South
  "Andhra Pradesh", "South",
  "Karnataka", "South",
  "Kerala", "South",
  "Tamil Nadu", "South",
  "Telangana", "South",
  "Puducherry", "South",
  "Lakshadweep", "South",
  "Andaman Nicobar Islands", "South",
  
  # West
  "Gujarat", "West",
  "Maharashtra", "West",
  "Goa", "West",
  "Rajasthan", "West",
  "Dadra Nagar Haveli", "West",
  "Daman Diu", "West",
  
  # Northeast
  "Assam", "Northeast",
  "Arunachal Pradesh", "Northeast",
  "Manipur", "Northeast",
  "Meghalaya", "Northeast",
  "Mizoram", "Northeast",
  "Nagaland", "Northeast",
  "Sikkim", "Northeast",
  "Tripura", "Northeast"
)

# ============================================================================
# VERSION 2: AIRSHEDS (4 categories) - SCIENTIFICALLY GROUNDED
# ============================================================================

airshed_mapping <- tribble(
  ~state_name, ~airshed,
  # Indo-Gangetic Plain (IGP) - Most polluted, well-defined airshed
  "Punjab", "IGP",
  "Haryana", "IGP",
  "Chandigarh", "IGP",
  "Nct of Delhi", "IGP",
  "Uttar Pradesh", "IGP",
  "Bihar", "IGP",
  "West Bengal", "IGP",
  
  # Central-East (Industrial/mining belt + arid dust)
  "Rajasthan", "Central-East",
  "Madhya Pradesh", "Central-East",
  "Jharkhand", "Central-East",
  "Chhattisgarh", "Central-East",
  "Odisha", "Central-East",
  
  # Peninsular (Deccan Plateau + Western coast)
  "Gujarat", "Peninsular",
  "Maharashtra", "Peninsular",
  "Goa", "Peninsular",
  "Telangana", "Peninsular",
  "Andhra Pradesh", "Peninsular",
  "Karnataka", "Peninsular",
  "Tamil Nadu", "Peninsular",
  "Kerala", "Peninsular",
  "Puducherry", "Peninsular",
  "Dadra Nagar Haveli", "Peninsular",
  "Daman Diu", "Peninsular",
  "Lakshadweep", "Peninsular",
  "Andaman Nicobar Islands", "Peninsular",
  
  # Mountain-NE (Himalayan region)
  "Jammu Kashmir", "Mountain-NE",
  "Himachal Pradesh", "Mountain-NE",
  "Uttarakhand", "Mountain-NE",
  "Sikkim", "Mountain-NE",
  "Arunachal Pradesh", "Mountain-NE",
  "Assam", "Mountain-NE",
  "Manipur", "Mountain-NE",
  "Meghalaya", "Mountain-NE",
  "Mizoram", "Mountain-NE",
  "Nagaland", "Mountain-NE",
  "Tripura", "Mountain-NE"
)

# ============================================================================
# SELECT WHICH VERSION TO USE: "geographic" or "airshed"
# ============================================================================
VERSION <- "airsheds"  # Change to "airshed" for airshed regions

# Prepare data based on selected version
state_annual <- final_all_years_cbind_df_sh_mapped_long %>%
  group_by(state_name, year) %>%
  summarise(
    mean_pollution = weighted.mean(avg_pm2.5, subdistrict_population, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(state_name = tools::toTitleCase(state_name))

if (VERSION == "geographic") {
  state_annual <- state_annual %>%
    left_join(geographic_mapping, by = "state_name") %>%
    mutate(category = coalesce(region, "West"))
  
  # Define colors explicitly for geographic regions (5 categories)
  category_colors <- c(
    "North & Central" = "#E57373",  # Soft red
    "East" = "#FF9800",             # Orange
    "South" = "#42A5F5",            # Blue
    "West" = "#FDD835",             # Yellow
    "Northeast" = "#66BB6A"         # Green
  )
  
  plot_title <- "India State Annual Average PM2.5 Rankings by Geographic Region (1998-2024)"
  plot_subtitle <- "Year: {closest_state}  |  East (Orange), North & Central (Red), Northeast (Green), South (Blue), West (Yellow)"
  legend_title <- "Geographic Region"
  
} else {  # airshed
  state_annual <- state_annual %>%
    left_join(airshed_mapping, by = "state_name") %>%
    mutate(category = coalesce(airshed, "Peninsular"))
  
  # Define colors explicitly for airsheds (4 categories)
  category_colors <- c(
    "IGP" = "#D32F2F",              # Dark red (most polluted)
    "Central-East" = "#FF9800",     # Orange
    "Peninsular" = "#42A5F5",       # Blue
    "Mountain-NE" = "#66BB6A"       # Green
  )
  
  plot_title <- "India State Annual Average PM2.5 Rankings by Airshed (1998-2024)"
  plot_subtitle <- "Year: {closest_state}  |  Central-East (Orange), IGP (Red), Mountain-NE (Green), Peninsular (Blue)"
  legend_title <- "Airshed"
}

# Complete data preparation
state_annual <- state_annual %>%
  group_by(year) %>%
  arrange(year, desc(mean_pollution)) %>%
  mutate(rank = row_number()) %>%
  ungroup() %>%
  mutate(state_name = ifelse(state_name == "Arunachal Pradesh", "Arun. P.", state_name), 
         state_name = ifelse(state_name == "Andaman Nicobar Islands", "A.N. Islands", state_name))

# Create the plot
p <- ggplot(state_annual, aes(x = rank, y = mean_pollution, fill = category)) +
  geom_hline(yintercept = 40, linetype = "dotted", color = "#FFA500", linewidth = 1.3) +
  geom_text(aes(x = max(rank), y = 83, label = "India Annual Avg PM2.5 Limit (40 µg/m³)"),
            hjust = 1, vjust = 2.85, size = 6, color = "#FFA500", fontface = "bold") +
  geom_hline(yintercept = 5, linetype = "dotted", color = "cornflowerblue", linewidth = 1.3) +
  geom_text(aes(x = max(rank), y = 32, label = "WHO Guideline (5 µg/m³)"),
            hjust = 1, vjust = 2.85, size = 6, color = "cornflowerblue", fontface = "bold") +
  geom_col(alpha = 0.9, width = 0.9) +
  # State names
  geom_text(aes(y = mean_pollution, label = state_name), 
            hjust = 1.05, 
            size = 5, 
            color = "#FFFFFF",
            fontface = "bold") +
  # Pollution values
  geom_text(aes(y = mean_pollution, label = sprintf("%.1f", mean_pollution)), 
            hjust = -0.15, 
            size = 4.5, 
            color = "#E8E8E8",
            fontface = "bold") +
  # Color scale
  scale_fill_manual(values = category_colors, name = legend_title) +
  coord_flip(clip = "off") +
  scale_x_reverse() +
  labs(
    title = plot_title,
    subtitle = plot_subtitle,
    x = NULL,
    y = "Population-Weighted Mean PM2.5 (µg/m³)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(size = 20, hjust = 0.5, color = "#E8E8E8", 
                              face = "bold", margin = margin(b = 5)),
    plot.subtitle = element_text(size = 14, hjust = 0.5, color = "#B8B8B8",
                                 margin = margin(b = 15)),
    axis.text.y = element_blank(),
    axis.text.x = element_text(size = 13, color = "#E8E8E8"),
    axis.title.x = element_text(size = 15, color = "#B0B0B0", margin = margin(t = 15)),
    axis.ticks = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "#2a2a2a", linewidth = 0.3),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.title = element_text(color = "#E8E8E8", size = 13, face = "bold"),
    legend.text = element_text(color = "#E8E8E8", size = 12),
    legend.key.size = unit(1.2, "cm"),
    legend.background = element_rect(fill = "#0f0f0f", color = "#FFFFFF", linewidth = 1),
    legend.box.background = element_rect(fill = "#0f0f0f", color = "#FFFFFF", linewidth = 1),
    legend.margin = margin(10, 10, 10, 10),
    plot.background = element_rect(fill = "#0f0f0f", color = NA),
    panel.background = element_rect(fill = "#0f0f0f", color = NA),
    plot.margin = margin(20, 60, 20, 120)
  )

# Animate the plot
anim <- p +
  transition_states(year, 
                    transition_length = 2, 
                    state_length = 1) +
  ease_aes('cubic-in-out') +
  enter_fade() +
  exit_fade()

# Render the animation
p_anim_custom <- animate(anim, 
        nframes = 300,
        fps = 10, 
        width = 1200, 
        height = 1200,
        renderer = gifski_renderer())

# Save the animation
if (VERSION == "geographic") {
  anim_save("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/pollution_race_geographic_regions.gif", animation = p_anim_custom)
} else {
  anim_save("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/pollution_race_airsheds.gif", animation = p_anim_custom)
}

#### subdistrict level compliance with national and who guideline===================

library(tidyverse)
library(patchwork)

# Calculate compliance counts by year-month
compliance_summary <- final_all_years_cbind_df_sh_mapped_long %>%
  group_by(year, month, state_name) %>%
  summarise(
    national_compliant = sum(avg_pm2.5 <= 40, na.rm = TRUE),
    who_compliant = ifelse(first(year) >= 2021, sum(avg_pm2.5 <= 5, na.rm = TRUE), sum(avg_pm2.5 <= 10, na.rm = TRUE)),
    total_subdistricts = n(),
    .groups = 'drop'
  ) %>%
  mutate(
    national_pct = (national_compliant / total_subdistricts) * 100,
    who_pct = (who_compliant / total_subdistricts) * 100,
    month_proper = str_to_title(month),
    month_name = factor(month_proper, 
                        levels = rev(c("January", "February", "March", "April", 
                                       "May", "June", "July", "August", 
                                       "September", "October", "November", "December"))),
    # Conditional text color: white for low % (red/dark), black for high % (yellow/light)
    national_text_color = ifelse(national_pct < 60, "black", "white"),
    who_text_color = ifelse(who_pct < 60, "black", "white")
  )

# National guideline heatmap
p1 <- ggplot(compliance_summary, 
             aes(x = factor(year), y = month_name, fill = national_pct)) +
  geom_tile(color = "white", linewidth = 2) +
  # geom_text(aes(label = sprintf("%.1f%%", national_pct), color = national_text_color), 
  #           size = 6, fontface = "bold") +
  scale_fill_gradient2(
    low = "#d73027", 
    mid = "#fee090", 
    high = "#1a9850",
    midpoint = 50,
    limits = c(0, 100),
    name = "% Compliant"
  ) +
  scale_color_identity() +  # Use the actual colors specified
  labs(
    title = "National Standard (≤40 µg/m³)",
    x = NULL,
    y = NULL
  ) +
  theme_minimal(base_size = 22) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 18),
    axis.text.y = element_text(size = 20),
    legend.position = "bottom",
    legend.title = element_text(size = 20),
    legend.text = element_text(size = 18),
    legend.key.width = unit(5, "cm"),
    legend.key.height = unit(1, "cm")
  ) + 
  facet_grid(~state_name)

# WHO guideline heatmap
p2 <- ggplot(compliance_summary, 
             aes(x = factor(year), y = month_name, fill = who_pct)) +
  geom_tile(color = "white", linewidth = 2) +
  geom_text(aes(label = sprintf("%.1f%%", who_pct), color = who_text_color), 
            size = 6, fontface = "bold") +
  scale_fill_gradient2(
    low = "#d73027", 
    mid = "#fee090", 
    high = "#1a9850",
    midpoint = 50,
    limits = c(0, 100),
    name = "% Compliant"
  ) +
  scale_color_identity() +  # Use the actual colors specified
  labs(
    title = "WHO Guideline (≤5 µg/m³ from 2021), before 2021: ≤10 µg/m³",
    x = "Year",
    y = NULL
  ) +
  theme_minimal(base_size = 22) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 24),
    panel.grid = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 18),
    axis.text.y = element_text(size = 20),
    axis.title.x = element_text(size = 20, face = "bold", margin = margin(t = 10)),
    legend.position = "bottom",
    legend.title = element_text(size = 20),
    legend.text = element_text(size = 18),
    legend.key.width = unit(5, "cm"),
    legend.key.height = unit(1, "cm")
  )

# Combine plots with descriptive title, subtitle, and caption
combined_plot <- p1 / p2 + 
  plot_annotation(
    title = "The Air Quality Crisis in India: A 27-Year View of PM2.5 Compliance",
    subtitle = "Percentage of 5,968 subdistricts meeting national and WHO air quality standards (1998-2024) Months show clear seasonal patterns, with monsoon months (June-September) exhibiting better compliance.There is also a diminishing\n 'greeness' in the national plot as we move from 1998 towards 2024. In any given month, later years have gotten 'on average' worse (especially October to April months) in terms of compliance compared to previous years.\nWhile the WHO guideline comparison is clear - practically no compliance under the stricter standard and only some compliance in previous less stricter standard, and that too only few non-winter months in early years.",
    caption = "Data: Population-weighted monthly PM2.5 concentrations across Indian subdistricts\nNational Standard: 40 µg/m³ annual average | WHO Guideline: 5 µg/m³ annual average (fro 2021) and 10 µg/m³ annual average (pre-2021)\nGreen = high compliance, Red = low compliance | Each cell shows percentage of subdistricts meeting the threshold\nGraphic: Aarsh Batra (github.com/AarshBatra/biteSizedAQ)",
    theme = theme(
      plot.title = element_text(size = 28, face = "bold", hjust = 0.5, margin = margin(b = 15)),
      plot.subtitle = element_text(size = 20, hjust = 0.5, color = "gray20", 
                                   lineheight = 1.3, margin = margin(b = 20)),
      plot.caption = element_text(size = 16, hjust = 0, color = "gray40", 
                                  lineheight = 1.4, margin = margin(t = 20))
    )
  )

print(combined_plot)

# Save as VERY LARGE high-resolution plot
ggsave("pm25_compliance_heatmap_who_2_limits.png", 
       combined_plot, 
       width = 30,
       height = 22,
       dpi = 300,
       bg = "white")

# Save as VERY LARGE high-resolution plot
ggsave("pm25_compliance_heatmap_who_1_limit.png", 
       p1, 
       width = 32,
       height = 20,
       dpi = 300,
       bg = "white")

#### IGP compliance stripes chart============================================
library(ggplot2)
library(dplyr)

convert_month <- function(x) {
  month.abb[ match(x, month.name) ]
}


# Create binned categories with distinct colors
compliance_summary_binned <- compliance_summary %>%
  mutate(
    compliance_bin_nat = cut(
      national_pct,
      breaks = c(0, 20, 40, 60, 80, 100),
      labels = c("0-20%", "20-40%", "40-60%", "60-80%", "80-100%"),
      include.lowest = TRUE
    ), 
     compliance_bin_who = cut(
      who_pct,
      breaks = c(0, 20, 40, 60, 80, 100),
      labels = c("0-20%", "20-40%", "40-60%", "60-80%", "80-100%"),
      include.lowest = TRUE
    )
  ) %>%
  mutate(state_name = str_to_title(state_name)) %>%
  mutate(month_name = recode(month_name, !!!setNames(month.abb, month.name))) %>%
   mutate(year_short = paste0("'", substr(as.character(year), 3, 4)))

# Define a bold, distinct color palette
stripe_colors <- c(
  "0-20%" = "#d73027",    # Deep red
  "20-40%" = "#fc8d59",   # Orange
  "40-60%" = "#fee090",   # Yellow
  "60-80%" = "#91cf60",   # Light green
  "80-100%" = "#1a9850"   # Deep green
)

# Then update your ggplot code to use year_short instead of year:
# COMPLIANCE STRIPES CHART - ALL 27 STATES
# COMPLIANCE STRIPES CHART - ALL 27 STATES
p1 <- ggplot(
  compliance_summary_binned,
  aes(x = factor(year), y = month_name, fill = compliance_bin_nat)
) +
  geom_tile(color = "white", linewidth = 0.3, width = 0.95, height = 0.95) +
  scale_fill_manual(
    values = stripe_colors,
    name = "% of Subdistricts\nMeeting National PM2.5 Standard",
    drop = FALSE
  ) +
  scale_x_discrete(
    breaks = seq(1998, 2024, 2),  # Show every 2 years
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  scale_y_discrete(expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    title = "Compliance Stripes: All Indian States Across 27 Years (1998 to 2024)",
    subtitle = "National PM2.5 Standard (≤40 µg/m³ annual average PM2.5)",
    x = "Year",
    y = NULL,
    caption = "Each stripe represents the percentage of subdistricts meeting the National PM2.5 standard in a given month-year\nGraphic: Aarsh Batra (github.com/AarshBatra/biteSizedAQ)"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 52, margin = margin(b = 8)),
    plot.subtitle = element_text(hjust = 0.5, size = 33, color = "grey30", margin = margin(b = 20)),
    plot.caption = element_text(hjust = 1, size = 23, color = "grey40", margin = margin(t = 20), lineheight = 1.2),
    panel.grid = element_blank(),
    panel.spacing.x = unit(1.5, "lines"),
    panel.spacing.y = unit(1.5, "lines"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 22),
    axis.text.y = element_text(size = 22),
    axis.title.x = element_text(size = 31, margin = margin(t = 1.2, b = 1, unit = "cm"), face = "bold"),
    strip.text = element_text(face = "bold", size = 28, margin = margin(b = 6, t = 6)),
    strip.background = element_blank(),
    legend.position = "bottom",
    legend.title = element_text(size = 30, face = "bold"),
    legend.text = element_text(size = 25),
    legend.key.width = unit(2, "cm"),
    legend.key.height = unit(0.6, "cm"),
    legend.background = element_rect(fill = "white", color = "grey60", linewidth = 0.5),
    legend.box.background = element_rect(fill = "white", color = "grey60", linewidth = 0.5),
    legend.margin = margin(12, 12, 12, 12),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(20, 20, 20, 20)
  ) +
  facet_wrap(~state_name, nrow = 5, ncol = 7, scales = "free")

# Save with appropriate dimensions for 27 states
ggsave("[test3]compliance_stripes_chart_all_states_nat.png", p1, 
       width = 54, height = 34, dpi = 520, bg = "white", limits = FALSE)


p2 <- ggplot(
  compliance_summary_binned,
  aes(x = factor(year), y = month_name, fill = compliance_bin_who)
) +
  geom_tile(color = "white", linewidth = 0.3, width = 0.95, height = 0.95) +
  scale_fill_manual(
    values = stripe_colors,
    name = "% of Subdistricts\nMeeting WHO PM2.5 Guideline",
    drop = FALSE
  ) +
  scale_x_discrete(
    breaks = seq(1998, 2024, 2),  # Show every 2 years
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  scale_y_discrete(expand = expansion(mult = c(0.02, 0.02))) +
  labs(
    title = "Compliance Stripes: All Indian States Across 27 Years (1998 to 2024)",
    subtitle = "WHO PM2.5 Guideline (≤5 µg/m³ annual average PM2.5)",
    x = "Year",
    y = NULL,
    caption = "Each stripe represents the percentage of subdistricts meeting the WHO PM2.5 guideline in a given month-year\nGraphic: Aarsh Batra (github.com/AarshBatra/biteSizedAQ)"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 52, margin = margin(b = 8)),
    plot.subtitle = element_text(hjust = 0.5, size = 33, color = "grey30", margin = margin(b = 20)),
    plot.caption = element_text(hjust = 1, size = 23, color = "grey40", margin = margin(t = 20), lineheight = 1.2),
    panel.grid = element_blank(),
    panel.spacing.x = unit(1.5, "lines"),
    panel.spacing.y = unit(1.5, "lines"),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 22),
    axis.text.y = element_text(size = 22),
    axis.title.x = element_text(size = 31, margin = margin(t = 1.2, b = 1, unit = "cm"), face = "bold"),
    strip.text = element_text(face = "bold", size = 28, margin = margin(b = 6, t = 6)),
    strip.background = element_blank(),
    legend.position = "bottom",
    legend.title = element_text(size = 30, face = "bold"),
    legend.text = element_text(size = 25),
    legend.key.width = unit(2, "cm"),
    legend.key.height = unit(0.6, "cm"),
    legend.background = element_rect(fill = "white", color = "grey60", linewidth = 0.5),
    legend.box.background = element_rect(fill = "white", color = "grey60", linewidth = 0.5),
    legend.margin = margin(12, 12, 12, 12),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(20, 20, 20, 20)
  ) +
  facet_wrap(~state_name, nrow = 5, ncol = 7, scales = "free")

# Save with appropriate dimensions for 27 states
ggsave("[test3]compliance_stripes_chart_all_states_who.png", p2, 
       width = 54, height = 34, dpi = 520, bg = "white", limits = FALSE)


#### Block level pollution spike plot====================================

library(sf)
library(dplyr)
library(ggplot2)

# Use your shapefile (already loaded as shrug_master_subdist_shp)
shp <- shrug_master_subdist_shp %>%
  filter(state_name == "uttar pradesh")

# Use your PM2.5 data (already loaded as final_all_years_cbind_df_sh_mapped_long)
pm25_data <- final_all_years_cbind_df_sh_mapped_long

# Calculate average PM2.5 per subdistrict (across all years/months)
# Or filter to specific period first
pm25_avg <- pm25_data %>%
  # filter(year == 2023, month == 12) %>%  # Optional: specific time period
  group_by(state_name, district_name, subdistrict_name) %>%
  summarise(pm25_mean = mean(avg_pm2.5, na.rm = TRUE), .groups = "drop")

# Get centroids
centroids <- st_centroid(shp)

# Join data - column names match exactly!
plot_data <- centroids %>%
  left_join(pm25_avg, by = c("state_name", "district_name", "subdistrict_name"))

# Create spike endpoints
spike_data <- plot_data %>%
  filter(!is.na(pm25_mean)) %>%
  mutate(
    # Scale factor - adjust multiplier to control spike height visibility
    spike_height = pm25_mean * 0.02,
    lon = st_coordinates(.)[,1],
    lat = st_coordinates(.)[,2],
    lat_top = lat + spike_height
  )

# Create plot
plt <- ggplot() +
  # Base map
  geom_sf(data = shp, fill = "grey90", color = "grey60", linewidth = 0.2) +
  # Spikes
  geom_segment(data = spike_data,
               aes(x = lon, xend = lon, 
                   y = lat, yend = lat_top,
                   color = pm25_mean),
               linewidth = 0.5, alpha = 0.7) +
  scale_color_gradient2(low = "green", mid = "yellow", high = "red",
                        midpoint = median(spike_data$pm25_mean, na.rm = TRUE),
                        name = "PM2.5 (μg/m³)") +
  theme_minimal() +
  labs(title = "PM2.5 Pollution Spikes by Subdistrict",
       subtitle = "Average across all time periods") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_blank())

# For a specific month/year:
# pm25_specific <- pm25_data %>%
#   filter(year == 2023, month == 11) %>%
#   group_by(state_name, district_name, subdistrict_name) %>%
#   summarise(pm25_mean = mean(avg_pm2.5, na.rm = TRUE), .groups = "drop")


#### pollution relief plot with spikes======================================

library(sf)
library(dplyr)
library(ggplot2)
library(rayshader)
library(raster)

# Use your data
shp <- shrug_master_subdist_shp %>%
  filter(state_name == "nct of delhi")
pm25_data <- final_all_years_cbind_df_sh_mapped_long

# Calculate average PM2.5 per subdistrict
pm25_avg <- final_all_years_cbind_df_sh_mapped_long %>%
  # filter(year == 2023, month == 11) %>%  # Optional: specific time period
  group_by(state_name, district_name, subdistrict_name) %>%
  summarise(pm25_mean = mean(avg_pm2.5, na.rm = TRUE), .groups = "drop")

# Join with shapefile
shp_data <- shp %>%
  left_join(pm25_avg, by = c("state_name", "district_name", "subdistrict_name"))

# Create base ggplot
p <- ggplot() +
  geom_sf(data = shp_data, aes(fill = pm25_mean), color = NA) +
  scale_fill_gradientn(
    colors = c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c"),
    na.value = "grey80",
    name = "PM2.5\n(μg/m³)"
  ) +
  theme_void() +
  labs(title = "PM2.5 Pollution Relief Map")

# Save plot for rayshader
ggsave("temp_pm25_plot.png", p, width = 8, height = 8, dpi = 300)

# Convert to 3D relief
plot_gg(p, 
        width = 7, 
        height = 7,
        scale = 250,           # Vertical exaggeration
        zoom = 0.6, 
        phi = 30,              # Viewing angle (vertical)
        theta = 45,            # Viewing angle (horizontal)
        windowsize = c(1200, 1200),
        multicore = TRUE)

# Render snapshot
render_snapshot("pm25_relief_3d.png")

# Alternative: Create hillshade effect in 2D
# This gives relief appearance without full 3D
p_relief <- ggplot() +
  geom_sf(data = shp_data, aes(fill = pm25_mean), color = "white", linewidth = 0.1) +
  scale_fill_gradientn(
    colors = c("#2c7bb6", "#abd9e9", "#ffffbf", "#fdae61", "#d7191c"),
    na.value = "grey80",
    name = "PM2.5\n(μg/m³)"
  ) +
  theme_void() +
  theme(
    plot.background = element_rect(fill = "#f0f0f0"),
    panel.background = element_rect(fill = "#f0f0f0"),
    legend.position = "right"
  ) +
  labs(title = "PM2.5 Pollution Relief Map",
       subtitle = "Higher values shown with warm colors")

print(p_relief)

# To rotate the 3D view interactively:
# render_camera(phi = 30, theta = 45, zoom = 0.6)

# For high-quality render:
render_highquality("pm25_relief_hq.png",
                   samples = 300,
                   preview = FALSE,
                   light = TRUE,
                   lightdirection = 45,
                   lightaltitude = 45)



#### cartogram plot===========================================================

# Load required libraries
library(sf)
library(cartogram)
library(ggplot2)
library(dplyr)
library(viridis)

# STRATEGY 1: State Level (FAST!)
# ================================
create_state_cartogram <- function(pollution_data, 
                                   state_shapefile,
                                   selected_year, 
                                   selected_month) {
  
  # Aggregate pollution data to state level
  state_pollution <- pollution_data %>%
    filter(year == selected_year, month == selected_month) %>%
    group_by(state_name) %>%
    summarise(
      avg_pm2.5 = weighted.mean(avg_pm2.5, subdistrict_population, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(state_name = tolower(trimws(state_name)))
  
  # Use existing state shapefile
  state_shp <- state_shapefile %>%
    mutate(state_name = tolower(trimws(state_name)))
  
  # Join and filter
  map_data <- state_shp %>%
    left_join(state_pollution, by = "state_name") %>%
    filter(!is.na(avg_pm2.5), avg_pm2.5 > 0)
  
  # Transform to projected CRS
  map_data_projected <- st_transform(map_data, crs = 24378)
  
  # Create cartogram (very fast with ~36 states)
  cartogram_map <- cartogram_cont(map_data_projected, 
                                  weight = "avg_pm2.5", 
                                  itermax = 5)
  
  # Create plot
  plot <- ggplot() +
    geom_sf(data = cartogram_map, 
            aes(fill = avg_pm2.5), 
            color = "white", 
            size = 0.3) +
    scale_fill_viridis(
      option = "inferno",
      name = expression(paste("PM"[2.5], " (μg/m"^3, ")")),
      guide = guide_colorbar(
        direction = "horizontal",
        title.position = "top",
        barwidth = 15,
        barheight = 0.5
      )
    ) +
    labs(
      title = "Air Pollution Cartogram - India (State Level)",
      subtitle = paste(tools::toTitleCase(selected_month), selected_year, 
                      "| Area warped by PM2.5 concentration"),
      caption = "Larger areas indicate higher pollution levels"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 12),
      plot.caption = element_text(hjust = 0.5, size = 9, color = "gray50"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank()
    )
  
  return(list(cartogram = cartogram_map, plot = plot))
}


# STRATEGY 2: State Level with State Labels
# ==========================================
create_state_cartogram_labeled <- function(pollution_data, 
                                           state_shapefile,
                                           selected_year, 
                                           selected_month) {
  
  # Aggregate pollution data to state level
  state_pollution <- pollution_data %>%
    filter(year == selected_year, month == selected_month) %>%
    group_by(state_name) %>%
    summarise(
      avg_pm2.5 = weighted.mean(avg_pm2.5, subdistrict_population, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(state_name = tolower(trimws(state_name)))
  
  # Use existing state shapefile
  state_shp <- state_shapefile %>%
    mutate(state_name = tolower(trimws(state_name)))
  
  # Join and filter
  map_data <- state_shp %>%
    left_join(state_pollution, by = "state_name") %>%
    filter(!is.na(avg_pm2.5), avg_pm2.5 > 0)
  
  # Transform to projected CRS
  map_data_projected <- st_transform(map_data, crs = 24378)
  
  # Create cartogram
  cartogram_map <- cartogram_cont(map_data_projected, 
                                  weight = "avg_pm2.5", 
                                  itermax = 5)
  
  # Get centroids for labels
  centroids <- st_centroid(cartogram_map)
  
  # Create plot with state labels
  plot <- ggplot() +
    geom_sf(data = cartogram_map, 
            aes(fill = avg_pm2.5), 
            color = "white", 
            size = 0.3) +
    geom_sf_text(data = centroids,
                 aes(label = toupper(substr(state_name, 1, 3))),
                 size = 2.5,
                 color = "white",
                 fontface = "bold") +
    scale_fill_viridis(
      option = "inferno",
      name = expression(paste("PM"[2.5], " (μg/m"^3, ")")),
      guide = guide_colorbar(
        direction = "horizontal",
        title.position = "top",
        barwidth = 15,
        barheight = 0.5
      )
    ) +
    labs(
      title = "Air Pollution Cartogram - India (State Level)",
      subtitle = paste(tools::toTitleCase(selected_month), selected_year, 
                      "| Area warped by PM2.5 concentration"),
      caption = "Larger areas indicate higher pollution levels"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 12),
      plot.caption = element_text(hjust = 0.5, size = 9, color = "gray50"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank()
    )
  
  return(list(cartogram = cartogram_map, plot = plot))
}


# STRATEGY 2: Simplify Geometry (Faster but still slow)
# ======================================================
create_simplified_cartogram <- function(pollution_data, 
                                        shapefile, 
                                        selected_year, 
                                        selected_month,
                                        simplify_tolerance = 1000) {
  
  # Filter and join data
  filtered_data <- pollution_data %>%
    filter(year == selected_year, month == selected_month) %>%
    mutate(across(c(state_name, district_name, subdistrict_name), 
                  ~tolower(trimws(.))))
  
  shapefile_clean <- shapefile %>%
    mutate(across(c(state_name, district_name, subdistrict_name), 
                  ~tolower(trimws(.))))
  
  map_data <- shapefile_clean %>%
    left_join(filtered_data, 
              by = c("state_name", "district_name", "subdistrict_name")) %>%
    filter(!is.na(avg_pm2.5), avg_pm2.5 > 0)
  
  # Transform to projected CRS
  map_data_projected <- st_transform(map_data, crs = 24378)
  
  # Simplify geometry to reduce computation
  # Higher tolerance = more simplification = faster but less detail
  map_data_simple <- st_simplify(map_data_projected, 
                                 dTolerance = simplify_tolerance,
                                 preserveTopology = TRUE)
  
  # Create cartogram with simplified geometry
  cartogram_map <- cartogram_cont(map_data_simple, 
                                  weight = "avg_pm2.5", 
                                  itermax = 3)  # Reduced iterations
  
  # Create plot
  plot <- ggplot() +
    geom_sf(data = cartogram_map, 
            aes(fill = avg_pm2.5), 
            color = "white", 
            size = 0.05) +
    scale_fill_viridis(
      option = "inferno",
      name = expression(paste("PM"[2.5], " (μg/m"^3, ")")),
      guide = guide_colorbar(
        direction = "horizontal",
        title.position = "top",
        barwidth = 15,
        barheight = 0.5
      )
    ) +
    labs(
      title = "Air Pollution Cartogram - India (Subdistrict Level)",
      subtitle = paste(tools::toTitleCase(selected_month), selected_year, 
                      "| Area warped by PM2.5 concentration"),
      caption = "Larger areas indicate higher pollution levels"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 12),
      plot.caption = element_text(hjust = 0.5, size = 9, color = "gray50"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank()
    )
  
  return(list(cartogram = cartogram_map, plot = plot))
}


# STRATEGY 3: Non-Contiguous Cartogram (MUCH FASTER!)
# ====================================================
create_noncont_cartogram <- function(pollution_data, 
                                     shapefile, 
                                     selected_year, 
                                     selected_month) {
  
  # Filter and join data
  filtered_data <- pollution_data %>%
    filter(year == selected_year, month == selected_month) %>%
    mutate(across(c(state_name, district_name, subdistrict_name), 
                  ~tolower(trimws(.))))
  
  shapefile_clean <- shapefile %>%
    mutate(across(c(state_name, district_name, subdistrict_name), 
                  ~tolower(trimws(.))))
  
  map_data <- shapefile_clean %>%
    left_join(filtered_data, 
              by = c("state_name", "district_name", "subdistrict_name")) %>%
    filter(!is.na(avg_pm2.5), avg_pm2.5 > 0)
  
  # Transform to projected CRS
  map_data_projected <- st_transform(map_data, crs = 24378)
  
  # Use non-contiguous cartogram (scales polygons independently - FAST!)
  cartogram_map <- cartogram_ncont(map_data_projected, 
                                   weight = "avg_pm2.5",
                                   k = 1.5)  # Scaling factor
  
  # Create plot
  plot <- ggplot() +
    geom_sf(data = cartogram_map, 
            aes(fill = avg_pm2.5), 
            color = "white", 
            size = 0.05) +
    scale_fill_viridis(
      option = "inferno",
      name = expression(paste("PM"[2.5], " (μg/m"^3, ")")),
      guide = guide_colorbar(
        direction = "horizontal",
        title.position = "top",
        barwidth = 15,
        barheight = 0.5
      )
    ) +
    labs(
      title = "Air Pollution Cartogram - India (Non-Contiguous)",
      subtitle = paste(tools::toTitleCase(selected_month), selected_year, 
                      "| Size scaled by PM2.5 concentration"),
      caption = "Larger polygons indicate higher pollution levels"
    ) +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 12),
      plot.caption = element_text(hjust = 0.5, size = 9, color = "gray50"),
      axis.text = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank()
    )
  
  return(list(cartogram = cartogram_map, plot = plot))
}


# RECOMMENDED USAGE:
# ==================
# Use your existing state shapefile - SUPER FAST!
result <- create_state_cartogram(
  pollution_data = final_all_years_cbind_df_sh_mapped_long,
  state_shapefile = ind_st_level_shp,  # Your existing state shapefile
  selected_year = 1998,
  selected_month = "april"
)
# print(result$plot)

# With state labels (abbreviated to 3 letters)
# result <- create_state_cartogram_labeled(
#   pollution_data = your_data,
#   state_shapefile = india_state_shp,  # Your existing state shapefile
#   selected_year = 1998,
#   selected_month = "december"
# )
# print(result$plot)

# If you need subdistrict detail, use Strategy 3 (Non-contiguous) - FAST
# result <- create_noncont_cartogram(
#   pollution_data = your_data,
#   shapefile = india_subdist_shp,
#   selected_year = 1998,
#   selected_month = "april"
# )
# print(result$plot)

# Only use Strategy 2 if you really need contiguous subdistrict cartogram
# (will still take several minutes)
# result <- create_simplified_cartogram(
#   pollution_data = your_data,
#   shapefile = india_subdist_shp,
#   selected_year = 1998,
#   selected_month = "april",
#   simplify_tolerance = 2000
# )
# print(result$plot)


# ============================================================================
# HEATWAVE MATRIX: Monthly heatmap across years
# ============================================================================
viz_heatwave_matrix <- function(df, 
                                selected_state = NULL,
                                selected_district = NULL,
                                selected_subdistrict = NULL) {
  
  cat("Building heatwave matrix...\n")
  
  # Determine what level we're plotting
  level <- if(!is.null(selected_subdistrict)) {
    "subdistrict"
  } else if(!is.null(selected_district)) {
    "district"
  } else if(!is.null(selected_state)) {
    "state"
  } else {
    "national"
  }
  
  # Filter data based on selection
  plot_data <- df %>%
    filter(!is.na(avg_pm2.5), !is.na(subdistrict_population), subdistrict_population > 0)
  
  if(!is.null(selected_state)) {
    plot_data <- plot_data %>% filter(state_name == selected_state)
  }
  if(!is.null(selected_district)) {
    plot_data <- plot_data %>% filter(district_name == selected_district)
  }
  if(!is.null(selected_subdistrict)) {
    plot_data <- plot_data %>% filter(subdistrict_name == selected_subdistrict)
  }
  
  # Population-weighted aggregation
  plot_data <- plot_data %>%
    mutate(month_num = match(tolower(month), tolower(month.name))) %>%
    filter(!is.na(month_num)) %>%
    group_by(year, month_num) %>%
    summarise(
      pm25 = sum(avg_pm2.5 * subdistrict_population) / sum(subdistrict_population),
      .groups = "drop"
    ) %>%
    mutate(month_name = factor(month.abb[month_num], levels = rev(month.abb)))
  
  # Create subtitle based on level
  subtitle_text <- case_when(
    level == "subdistrict" ~ paste0(selected_subdistrict, ", ", selected_district, ", ", selected_state),
    level == "district" ~ paste0(selected_district, ", ", selected_state),
    level == "state" ~ as.character(selected_state),
    TRUE ~ "All India"
  )
  
  cat("Level:", level, "\n")
  cat("Year range:", range(plot_data$year), "\n")
  cat("PM2.5 range:", range(plot_data$pm25), "\n")
  cat("Data points:", nrow(plot_data), "\n")
  
  ggplot(plot_data, aes(x = year, y = month_name, fill = pm25)) +
    geom_tile(color = "#0a0a0a", linewidth = 0.8) +
    scale_fill_gradientn(
      colors = c("#fffacd", "#ffed4e", "#ffba08", "#ff8500", 
                 "#ff5400", "#dc2f02", "#9d0208", "#6a040f", "#1a0000"),
      name = "PM2.5\n(μg/m³)",
      guide = guide_colorbar(barwidth = 1.5, barheight = 15)
    ) +
    scale_x_continuous(expand = c(0, 0), breaks = seq(1998, 2024, 2)) +
    scale_y_discrete(expand = c(0, 0)) +
    labs(
      title = "Air Quality Heatwave Matrix",
      subtitle = paste("Population-weighted PM2.5 concentration:", subtitle_text),
      x = "Year",
      y = NULL,
      caption = "Color scale: Light Yellow (Clean) → Orange → Red → Dark Red → Black (Hazardous)"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.background = element_rect(fill = "#0a0a0a", color = NA),
      panel.background = element_rect(fill = "#0a0a0a", color = NA),
      text = element_text(color = "#f0f0f0"),
      axis.text = element_text(color = "#d0d0d0", size = 11),
      axis.text.x = element_text(angle = 45, hjust = 1),
      axis.title.x = element_text(size = 13, margin = margin(t = 10)),
      panel.grid = element_blank(),
      legend.position = "right",
      plot.title = element_text(size = 20, face = "bold", margin = margin(b = 5)),
      plot.subtitle = element_text(size = 12, color = "#cccccc", margin = margin(b = 15)),
      plot.caption = element_text(size = 9, color = "#999999", hjust = 0.5, margin = margin(t = 10)),
      plot.margin = margin(20, 20, 20, 20)
    )
}

# USAGE:

# National level (all India):
 p3 <- viz_heatwave_matrix(final_all_years_cbind_df_sh_mapped_long)

# State level:
# p3 <- viz_heatwave_matrix(final_all_years_cbind_df_sh_mapped_long, 
#                           selected_state = "delhi")

# District level:
# p3 <- viz_heatwave_matrix(final_all_years_cbind_df_sh_mapped_long, 
#                           selected_state = "delhi", 
#                           selected_district = "central delhi")

# Subdistrict level:
# p3 <- viz_heatwave_matrix(final_all_years_cbind_df_sh_mapped_long, 
#                           selected_state = "delhi", 
#                           selected_district = "central delhi",
#                           selected_subdistrict = "kotwali")

# p3

# To save:
# ggsave("heatwave_matrix.png", p3, width = 16, height = 8, dpi = 300, bg = "#0f0f0f")
```

## GT table for the dataset

```{r}
library(gt)
library(dplyr)

# 1. Clean data and remove any duplicates or groups
table_ready <- final_all_years_cbind_df_sh_mapped_long %>%
  ungroup() %>%
  distinct() %>% 
  filter(!is.na(avg_pm2.5)) 

# 2. Build using ONLY native gt functions
interactive_pm25_table <- table_ready %>%
  gt(id = "stable_table") %>%
  
  # --- STYLING (Native gt) ---
  tab_header(
    title = md("**Air Quality Index Dashboard**"),
    subtitle = "Interactive PM2.5 monitoring by district"
  ) %>%
  data_color(
    columns = avg_pm2.5,
    palette = "Reds",
    domain = c(0, max(table_ready$avg_pm2.5))
  ) %>%
  fmt_number(columns = subdistrict_population, decimals = 0) %>%
  
  # --- MANUAL THEMING (To replace gt_theme_538) ---
  tab_options(
    table.font.names = "Arial",
    table.border.top.style = "none",
    table.width = pct(100),
    column_labels.border.top.style = "none",
    column_labels.border.bottom.width = 2,
    column_labels.border.bottom.color = "#333333",
    table_body.hlines.color = "#EEEEEE"
  ) %>%
  
  # --- SEARCH BARS ---
  opt_interactive(
    use_search = TRUE,
    use_filters = TRUE,
    use_pagination = TRUE,
    page_size_default = 10
  )

# 3. Render
interactive_pm25_table
```

## Testing Block [IGNORE]
```{r eval=FALSE, include=FALSE}

# Simple PM2.5 Monthly Stripes Visualization
# This script creates a simple climate stripe visualization for PM2.5 data
# showing 12 months for a specific block and year

# Load necessary libraries
library(ggplot2)
library(dplyr)
library(viridis)  # For the magma color palette

# -------------------------------------------------------
# PART 1: SIMPLE FUNCTION FOR SINGLE BLOCK-YEAR STRIPES
# -------------------------------------------------------

create_monthly_stripes <- function(data, selected_state, selected_district, selected_block, selected_year) {
  # Filter data for the specific block and year
  filtered_data <- data %>% 
    filter(
      state_name == selected_state,
      district_name == selected_district,
      subdistrict_name == selected_block,
      year == selected_year
    ) %>%
    # Ensure months are in correct order
    arrange(month)
  
# Create the plot with custom tile width
  p <- ggplot(filtered_data, aes(x = factor(month), y = 1, fill = avg_pm2.5)) +
    # Set width of tiles (0.9 means 90% of available space)
    geom_tile(width = 0.9) +
    scale_fill_viridis_c(
      name = "PM2.5 (μg/m³)",
      option = "magma",      # Magma color palette
      direction = 1          # Direction: 1 for dark=high, -1 for dark=low
    ) +
    scale_x_discrete(
      breaks = 1:12,
      labels = month.abb     # Use abbreviated month names (Jan, Feb, etc.)
    ) +
    labs(
      title = paste("PM2.5 Monthly Pattern:", selected_block, selected_year),
      subtitle = paste("Population:", format(filtered_data$subdistrict_population[1], big.mark=",")),
      x = NULL, 
      y = NULL
    ) +
    theme_minimal() +
    theme(
      axis.text.y = element_blank(),
      axis.ticks = element_blank(),
      panel.grid = element_blank(),
      legend.position = "bottom",
      plot.title = element_text(hjust = 0.5, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 0, hjust = 0.5, size = 10, face = "bold")
    )
  
  return(p)
}

create_monthly_stripes(final_all_years_cbind_df_sh_mapped_long, selected_state =  "uttar pradesh", selected_district = "ghaziabad", selected_block = "modinagar", selected_year = "1998")

# -------------------------------------------------------
# PART 2: EXAMPLE USAGE WITH SAMPLE DATA
# -------------------------------------------------------

# Create sample data (replace this with your actual data)
set.seed(123)
sample_data <- expand.grid(
  state_name = "State1",
  district_name = "District1",
  subdistrict_name = paste0("Block", 1:5),
  year = 2020:2024,
  month = 1:12
)

sample_data$subdistrict_population <- round(runif(nrow(sample_data), 10000, 100000))

# Create PM2.5 data with seasonal pattern
sample_data$avg_pm2.5 <- 30 + 
                         # Year-over-year increase
                         (sample_data$year - 2020) * 5 + 
                         # Seasonal pattern (higher in winter months)
                         ifelse(sample_data$month %in% c(11, 12, 1, 2), 40, 
                           ifelse(sample_data$month %in% c(5, 6, 7, 8), -10, 0))

# Add some random variation
sample_data$avg_pm2.5 <- sample_data$avg_pm2.5 + rnorm(nrow(sample_data), mean = 0, sd = 10)

# Example: Create stripes for Block1 in 2022
example_plot <- create_monthly_stripes(sample_data, "Block1", 2022)
print(example_plot)

# Save plot (uncomment to use)
# ggsave("./22.ind.block.pm2.5.sat.data.processing.1998.2024/experimental.plots/Block1_2022_pm25_stripes.png", example_plot, width = 8, height = 2, dpi = 300)

# -------------------------------------------------------
# PART 3: SHINY APP SKELETON
# -------------------------------------------------------

# Uncomment and use this code as a starting point for your Shiny app

# library(shiny)
# 
# # UI
# ui <- fluidPage(
#   titlePanel("PM2.5 Monthly Climate Stripes"),
#   
#   sidebarLayout(
#     sidebarPanel(
#       # Block selection dropdown
#       selectInput("block", "Select Block:",
#                  choices = unique(sample_data$subdistrict_name)),
#       
#       # Year selection slider
#       sliderInput("year", "Select Year:",
#                  min = min(sample_data$year),
#                  max = max(sample_data$year),
#                  value = min(sample_data$year),
#                  step = 1,
#                  sep = ""),
#       
#       # Optional: Add filtering by state/district if needed
#       # selectInput("district", "Select District:",
#       #           choices = unique(sample_data$district_name))
#     ),
#     
#     mainPanel(
#       # Output plot
#       plotOutput("stripesPlot"),
#       
#       # Optional: Add summary statistics
#       verbatimTextOutput("summaryStats")
#     )
#   )
# )
# 
# # Server
# server <- function(input, output) {
#   # Reactive data filtering
#   filtered_data <- reactive({
#     sample_data %>%
#       filter(
#         subdistrict_name == input$block,
#         year == input$year
#       )
#   })
#   
#   # Generate the stripes plot
#   output$stripesPlot <- renderPlot({
#     create_monthly_stripes(sample_data, input$block, input$year)
#   })
#   
#   # Optional: Generate summary statistics
#   output$summaryStats <- renderPrint({
#     data_summary <- filtered_data() %>%
#       summarize(
#         avg = mean(avg_pm2.5, na.rm = TRUE),
#         min = min(avg_pm2.5, na.rm = TRUE),
#         max = max(avg_pm2.5, na.rm = TRUE)
#       )
#     
#     cat("Average PM2.5:", round(data_summary$avg, 1), "μg/m³\n")
#     cat("Range:", round(data_summary$min, 1), "to", round(data_summary$max, 1), "μg/m³\n")
#   })
# }
# 
# # Run the app
# shinyApp(ui = ui, server = server)

#### [experimetation] number of blocks exceeding x micrograms per cubic meter

# Set threshold
threshold <- 5

# Add column for number of months exceeding threshold
df1 <- final_all_years_cbind_df_sh_mapped_wide %>%
  rowwise() %>%
  mutate(
    months_exceeding_threshold = sum(c_across(starts_with("avg_pm2.5_")) > threshold, na.rm = TRUE)
  ) %>%
  ungroup()


# plt <- df1 %>%
#   filter(months_exceeding_threshold > 300)
#   ggplot() + 
#   geom_histogram(mapping = aes(x = months_exceeding_threshold), color = "white") 
  
  
# Create summary data for plotting
plot_data <- tibble(threshold = 0:max(df1$months_exceeding_threshold)) %>%
  rowwise() %>%
  mutate(
    percent_blocks_exceeding = mean(df1$months_exceeding_threshold > threshold) * 100
  ) %>%
  ungroup()

# Create the plot
plt <- ggplot(plot_data, aes(x = threshold, y = percent_blocks_exceeding)) +
  geom_line(color = "steelblue", size = 1) +
  labs(
    title = paste0("Share of Indian Blocks exceeding WHO annual average PM2.5 guideline"),
     subtitle = paste0("WHO annual average PM2.5 safe limit: ", threshold,  " μg/m³"),
    x = paste0("Number of months (1998 to 2024) exceeding 5 μg/m³"),
    y = "Percent of Blocks (%)", 
    caption = "*Note:There are a total of 324 months from 1998 to 2024"
  ) +
  theme_minimal() +
  theme(plot.caption = element_text(hjust = 0, margin = margin(t = 1, unit = "cm"), face = "italic", size = 9), 
        plot.subtitle = element_text(hjust = 0, margin = margin(b = 0.8, unit = "cm"), face = "italic", size = 10), 
             plot.title = element_text(hjust = 0, margin = margin(b = 0.2, unit = "cm"), face = "bold", size = 13), 
        axis.title.x = element_text(size = 11, margin = margin(t = 0.5, unit = "cm")), 
        axis.title.y = element_text(size = 11, margin = margin(r = 0.5, unit = "cm")), 
        axis.text = element_text(size = 10))



#### Delhi block level names map------------------------------

library(ggspatial)

# Extract the Delhi shapefile
delhi_sf <- shrug_master_subdist_shp %>%
  filter(state_name %in% c("nct of delhi"))

# Get the centroid coordinates for labeling
# This avoids font issues with geom_sf_text
delhi_centroids <- delhi_sf %>%
  st_centroid() %>%
  st_coordinates() %>%
  as.data.frame() %>%
  bind_cols(
    subdistrict_name = delhi_sf$subdistrict_name
    
  )

delhi_map <- ggplot() +
  # Base layer with clean outline and subtle background
  geom_sf(
    data = delhi_sf,
    fill = "gray98",
    color = "gray50",
    size = 0.3
  ) +
  # Add improved labels with better styling and placement
  geom_label_repel(
    data = delhi_centroids,
    aes(x = X, y = Y, label = subdistrict_name),
    color = "gray15",
    fill = alpha("white", 0.9),
    label.size = 0.15,
    size = 10,
    segment.color = "gray60",
    segment.size = 0.2,
    segment.alpha = 0.7,
    box.padding = 0.35,
    point.padding = 0.5,
    force = 10,
    max.overlaps = 40,
    min.segment.length = 0,
    label.padding = 0.15,
    label.r = unit(0.15, "lines"),
    seed = 42 # For reproducible placement
  ) +
  # Add subtle dots for centroids
  geom_point(
    data = delhi_centroids,
    aes(x = X, y = Y),
    size = 0.4,
    color = "gray40",
    alpha = 0.7
  ) +
  # Customize the coordinate appearance
  coord_sf(expand = FALSE) +
  # Add scale bar with improved styling
  annotation_scale(
    location = "br",
    width_hint = 0.15,    # Keep original width
    style = "bar",        # Bar style for better visibility
    pad_x = unit(0.4, "cm"),
    pad_y = unit(0.4, "cm"),
    text_family = "franklin",
    text_col = "black",   # Darker text
    line_col = "black",   # Darker line
    bar_cols = c("black", "white"), # High contrast colors
    height = unit(0.25, "cm"), # Slightly taller
    text_cex = 1.1        # Slightly larger text
  ) +
  # Add north arrow with improved styling
  annotation_north_arrow(
    location = "tr",
    which_north = "true",
    pad_x = unit(0.4, "cm"),
    pad_y = unit(0.4, "cm"),
    style = north_arrow_fancy_orienteering(
      line_col = "black",
      fill = "gray30",
      text_col = "black",
      text_size = 14,
      line_width = 1.5
    ),
    height = unit(1.5, "cm"),
    width = unit(1.5, "cm")
  ) +
  # Clean, minimalist theme
  theme_map() +
  labs(title = "NCT of Delhi Blocks") +
  theme(
    plot.title = element_text(size = 46, hjust = 0.5, margin = margin(b = 1, t = 0.5, unit = "cm")), 
    panel.border = element_rect(color = "black", fill = NA, size = 0.3), 
    plot.background = element_rect(fill = "white", color = "white")
  )


#### Sanity Check: state, year wise population weight annual average pm2.5 (for comaprison with ACAG estimates)
foo <- final_all_years_cbind_df_sh_mapped_long %>% group_by(state_name, year, month) %>% mutate(st_pop = sum(subdistrict_population, na.rm = TRUE), pop_wt = subdistrict_population/st_pop, pop_wt_pm2.5 = pop_wt*avg_pm2.5) %>% summarise(avg_st_yr_pm2.5 = sum(pop_wt_pm2.5, na.rm = TRUE)) %>% ungroup() 
  

```



